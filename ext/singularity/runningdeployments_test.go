package singularity

import (
	"log"
	"testing"

	"github.com/opentable/go-singularity/dtos"
	"github.com/opentable/sous/lib"
	"github.com/samsalisbury/semv"
)

// defaultTestFixture is the starting point for all tests.
// Test modify this to make interesting assertions.
//
// It returns a testFixture for modification and a Deployer hooked up to use the
// fixture's Registry, DeployReaderFactory and Clusters.
func defaultTestFixture() (*testFixture, *Deployer) {
	fixture := &testFixture{
		Registry: newTestRegistry(),
	}

	singularity1 := fixture.AddSingularity("http://singularity1.com")
	singularity1.AddCluster("cluster1")

	// 1 cluster on singularity2.
	//cluster3 := fixture.AddCluster("cluster3", "http://singularity2.com")

	// Add 1 requests to cluster 1.
	cluster1Request1 := singularity1.AddRequest("github.com>user>repo1::cluster1", nil)
	cluster1Request2 := singularity1.AddRequest("github.com>user>repo2::cluster1", nil)

	// Add 2 successful deployments to cluster 1, request 1.
	cluster1Request1.AddDeploy("deploy111", nil)
	cluster1Request1.AddDeploy("deploy112", nil)

	// Add 1 successful deployment to cluster 1, request 2.
	cluster1Request2.AddDeploy("deploy121", nil)

	return fixture, &Deployer{
		Registry:      fixture.Registry,
		ClientFactory: fixture.DeployReaderFactory,
		Clusters:      fixture.Clusters,
	}
}

// defaultSingularityRequestParent returns a standard singularity request with a
// single successful deployment.
func (ts *testSingularity) defaultSingularityRequestParent(requestID, deployID string) *dtos.SingularityRequestParent {
	request := ts.AddRequest(requestID, nil)
	request.AddDeploy(deployID, nil)
	return request.RequestParent
}

// defaultExpectedDeployState returns a sous.DeployState that corresponds with
// the singularity request produced by defaultSingularityRequest.
func defaultExpectedDeployState(deployID string, configure func(*sous.DeployState)) *sous.DeployState {
	did, err := sous.ParseDeployID(deployID)
	if err != nil {
		log.Panic(err)
	}
	ds := &sous.DeployState{
		Status: sous.DeployStatusActive,
		Deployment: sous.Deployment{
			Kind: sous.ManifestKindService,
			SourceID: sous.SourceID{
				Location: did.ManifestID.Source,
				Version:  semv.MustParse("1"),
			},
			Flavor:      did.ManifestID.Flavor,
			ClusterName: did.Cluster,
			DeployConfig: sous.DeployConfig{
				NumInstances: 3, // From the SingularityRequest.
				Env: sous.Env{
					"TEST_ENV_VAR": "YES",
				},
				Resources: sous.Resources{
					"cpus":   "1.23",
					"memory": "123.45",
					"ports":  "1",
				},
				Volumes: sous.Volumes{
					&sous.Volume{
						Host:      "/host/path",
						Container: "/container/path",
						Mode:      sous.ReadWrite,
					},
				},
			},
		},
	}
	if configure != nil {
		configure(ds)
	}
	return ds
}

// defaultExpectedDeployStates returns the expected deploy states generated by
// defaultTextFixture.
func defaultExpectedDeployStates() sous.DeployStates {
	return sous.NewDeployStates(
		defaultExpectedDeployState("github.com/user/repo1:cluster1", nil),
		defaultExpectedDeployState("github.com/user/repo2:cluster1", nil),
	)
}

func TestDeployer_RunningDeployments_defaultTestFixture(t *testing.T) {

	// Setup.
	_, deployer := defaultTestFixture()

	// Act.
	actual, err := deployer.RunningDeployments()
	if err != nil {
		t.Fatal(err) // We are only testing happy paths in this go file.
	}

	// Assert.
	expected := defaultExpectedDeployStates()

	different, diffs := actual.Diff2(expected)
	if !different {
		return // Success!
	}
	for _, d := range diffs {
		t.Error(d)
	}
}

func TestDeployer_RunningDeployments(t *testing.T) {
	testCases := []struct {
		InputModifier    InputModifier
		ExpectedModifier ExpectedModifier
	}{
		{
			modifyInputRequestParent("http://singularity1.com", "github.com>user>repo1::cluster1",
				func(request *testRequest) {
					// Add a new pending deployment.
					request.AddDeploy("newDeploy", func(d *dtos.SingularityDeployHistory) {
						d.DeployResult.DeployState = dtos.SingularityDeployResultDeployStateWAITING
					})
				}),
			modifyExpectedDeployState(sous.MustParseDeployID("github.com/user/repo1:cluster1"),
				func(ds *sous.DeployState) {
					// Expect the deploy state to be pending.
					ds.Status = sous.DeployStatusPending
				}),
		},
	}

	for _, test := range testCases {

		// Set up the input.
		fixture, deployer := defaultTestFixture()
		test.InputModifier(fixture)

		// Set up expectations.
		expected := defaultExpectedDeployStates()
		test.ExpectedModifier(&expected)

		// Get the actual output.
		actual, err := deployer.RunningDeployments()
		if err != nil {
			// These tests are only concerned with non-error states.
			t.Fatal(err)
		}

		// Assert actual == expected.
		different, diffs := actual.Diff2(expected)
		if !different {
			return // Success!
		}
		for _, d := range diffs {
			t.Error(d)
		}
	}
}

type InputModifier func(*testFixture)
type ExpectedModifier func(*sous.DeployStates)

func modifyInputRequestParent(singularityBaseURL, requestID string, modifyRequestParent func(*testRequest)) InputModifier {
	return func(fixture *testFixture) {
		singularity, ok := fixture.Singularities[singularityBaseURL]
		if !ok {
			log.Panicf("No singularity called %q", singularityBaseURL)
		}
		request, ok := singularity.Requests[requestID]
		if !ok {
			log.Panicf("Singularity %q contains no request %q", singularityBaseURL, requestID)
		}
		modifyRequestParent(request)
	}
}

func modifyExpectedDeployState(did sous.DeployID, modifyDeployState func(*sous.DeployState)) ExpectedModifier {
	return func(deployStates *sous.DeployStates) {
		deployState, ok := deployStates.Get(did)
		if !ok {
			log.Panicf("No deploy ID called %q", did)
		}
		// Modify and re-set the deploy state as that doesn't rely on it being a
		// pointer.
		modifyDeployState(deployState)
		deployStates.Set(deployState.ID(), deployState)
	}
}

//func TestDeployer_RunningDeployments_pendingDeploy(t *testing.T) {
//
//	fixture, deployer := defaultTestFixture()
//	request.AddDeploy("newDeployID", func(deployHistory *dtos.SingularityDeployHistory) {
//
//		// The next line is significant.
//		deployHistory.DeployResult.DeployState = dtos.SingularityDeployResultDeployStateWAITING
//
//	})
//
//	actual, err := deployer.RunningDeployments()
//	if err != nil {
//		t.Fatal(err)
//	}
//
//	expected := defaultExpectedDeployStates()
//	deployID, err := sous.ParseDeployID("github.com/user/repo1:cluster1")
//	if err != nil {
//		t.Fatal(err)
//	}
//	deploy, ok := expected.Get(deployID)
//	if !ok {
//		t.Fatalf("deploy %q not found", deployID)
//	}
//	deploy.Status = sous.DeployStatusPending
//
//	different, diffs := actual.Diff2(expected)
//	if !different {
//		return // Success!
//	}
//	for _, d := range diffs {
//		t.Error(d)
//	}
//}
