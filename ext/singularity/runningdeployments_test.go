package singularity

import (
	"log"
	"testing"

	"github.com/opentable/go-singularity/dtos"
	"github.com/opentable/sous/lib"
	"github.com/samsalisbury/semv"
)

// defaultTestFixture is the starting point for all tests.
// Test modify this to make interesting assertions.
//
// It returns a testFixture for modification and a Deployer hooked up to use the
// fixture's Registry, DeployReaderFactory and Clusters.
func defaultTestFixture() (*testFixture, *Deployer) {
	fixture := &testFixture{
		Registry: newTestRegistry(),
	}

	singularity1 := fixture.AddSingularity("http://singularity1.com")
	singularity1.AddCluster("cluster1")

	// 1 cluster on singularity2.
	//cluster3 := fixture.AddCluster("cluster3", "http://singularity2.com")

	// Add 1 requests to cluster 1.
	cluster1Request1 := singularity1.AddRequest("github.com>user>repo1::cluster1", nil)
	cluster1Request2 := singularity1.AddRequest("github.com>user>repo2::cluster1", nil)

	// Add 2 successful deployments to cluster 1, request 1.
	cluster1Request1.AddDeploy("deploy111", nil)
	cluster1Request1.AddDeploy("deploy112", nil)

	// Add 1 successful deployment to cluster 1, request 2.
	cluster1Request2.AddDeploy("deploy121", nil)

	return fixture, &Deployer{
		Registry:      fixture.Registry,
		ClientFactory: fixture.DeployReaderFactory,
		Clusters:      fixture.Clusters,
	}
}

// defaultSingularityRequestParent returns a standard singularity request with a
// single successful deployment.
func (ts *testSingularity) defaultSingularityRequestParent(requestID, deployID string) *dtos.SingularityRequestParent {
	request := ts.AddRequest(requestID, nil)
	request.AddDeploy(deployID, nil)
	return request.RequestParent
}

// defaultExpectedDeployState returns a sous.DeployState that corresponds with
// the singularity request produced by defaultSingularityRequest.
func defaultExpectedDeployState(deployID string, configure func(*sous.DeployState)) *sous.DeployState {
	did, err := sous.ParseDeployID(deployID)
	if err != nil {
		log.Panic(err)
	}
	ds := &sous.DeployState{
		Status: sous.DeployStatusActive,
		Deployment: sous.Deployment{
			Kind: sous.ManifestKindService,
			SourceID: sous.SourceID{
				Location: did.ManifestID.Source,
				Version:  semv.MustParse("1"),
			},
			Flavor:      did.ManifestID.Flavor,
			ClusterName: did.Cluster,
			DeployConfig: sous.DeployConfig{
				NumInstances: 3, // From the SingularityRequest.
				Env: sous.Env{
					"TEST_ENV_VAR": "YES",
				},
				Resources: sous.Resources{
					"cpus":   "1.23",
					"memory": "123.45",
					"ports":  "1",
				},
				Volumes: sous.Volumes{
					&sous.Volume{
						Host:      "/host/path",
						Container: "/container/path",
						Mode:      sous.ReadWrite,
					},
				},
			},
		},
	}
	if configure != nil {
		configure(ds)
	}
	return ds
}

// defaultExpectedDeployStates returns the expected deploy states generated by
// defaultTextFixture.
func defaultExpectedDeployStates() sous.DeployStates {
	return sous.NewDeployStates(
		defaultExpectedDeployState("github.com/user/repo1:cluster1", nil),
		defaultExpectedDeployState("github.com/user/repo2:cluster1", nil),
	)
}

func TestDeployer_RunningDeployments_defaultTestFixture(t *testing.T) {

	// Setup.
	_, deployer := defaultTestFixture()

	// Act.
	actual, err := deployer.RunningDeployments()
	if err != nil {
		t.Fatal(err) // We are only testing happy paths in this go file.
	}

	// Assert.
	expected := defaultExpectedDeployStates()

	different, diffs := actual.Diff2(expected)
	if !different {
		return // Success!
	}
	for _, d := range diffs {
		t.Error(d)
	}
}

func TestDeployer_RunningDeployments_pendingDeploy(t *testing.T) {

	fixture, deployer := defaultTestFixture()
	singularity := fixture.Singularities["http://singularity1.com"]
	request := singularity.Requests["github.com>user>repo1::cluster1"]
	request.AddDeploy("newDeployID", func(deployHistory *dtos.SingularityDeployHistory) {

		// The next line is significant.
		deployHistory.DeployResult.DeployState = dtos.SingularityDeployResultDeployStateWAITING

	})

	actual, err := deployer.RunningDeployments()
	if err != nil {
		t.Fatal(err)
	}

	expected := defaultExpectedDeployStates()
	deployID, err := sous.ParseDeployID("github.com/user/repo1:cluster1")
	if err != nil {
		t.Fatal(err)
	}
	deploy, ok := expected.Get(deployID)
	if !ok {
		t.Fatalf("deploy %q not found", deployID)
	}
	deploy.Status = sous.DeployStatusPending

	different, diffs := actual.Diff2(expected)
	if !different {
		return // Success!
	}
	for _, d := range diffs {
		t.Error(d)
	}
}
