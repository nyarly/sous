package singularity

import (
	"fmt"
	"log"
	"testing"

	"github.com/opentable/go-singularity/dtos"
	sous "github.com/opentable/sous/lib"
	"github.com/samsalisbury/semv"
)

func defaultDeployHistoryItem(requestID, deployID string) *dtos.SingularityDeployHistory {
	did, err := ParseRequestID(requestID)
	if err != nil {
		log.Panic(err)
	}
	dockerImage := fmt.Sprintf("docker.mycompany.com/%s:1.0.0", did.ManifestID.Source)
	return &dtos.SingularityDeployHistory{
		Deploy: &dtos.SingularityDeploy{
			Id: deployID,
			ContainerInfo: &dtos.SingularityContainerInfo{
				Type: dtos.SingularityContainerInfoSingularityContainerTypeDOCKER,
				Docker: &dtos.SingularityDockerInfo{
					Image: dockerImage,
				},
				Volumes: dtos.SingularityVolumeList{
					&dtos.SingularityVolume{
						HostPath:      "/onhost",
						ContainerPath: "/indocker",
						Mode:          dtos.SingularityVolumeSingularityDockerVolumeModeRW,
					},
				},
			},
			Resources: &dtos.Resources{},
		},
		// Empty deploy result by default.
		DeployResult: &dtos.SingularityDeployResult{},
	}
}

func defaultRequestParent(requestID string) *dtos.SingularityRequestParent {
	return &dtos.SingularityRequestParent{
		RequestDeployState: &dtos.SingularityRequestDeployState{},
		Request: &dtos.SingularityRequest{
			Id:          requestID,
			RequestType: dtos.SingularityRequestRequestTypeSERVICE,
		},
	}
}

// defaultTestFixture is the starting point for all tests.
// Test modify this to make interesting assertions.
//
// It returns a testFixture for modification and a Deployer hooked up to use the
// fixture's Registry, DeployReaderFactory and Clusters.
func defaultTestFixture() (*testFixture, *Deployer) {
	fixture := &testFixture{
		Registry: newTestRegistry(),
	}

	cluster1 := fixture.AddCluster("cluster1", "http://cluster1.com")

	requestID1 := "github.com>user>repo::cluster1"

	request1 := cluster1.AddRequest(requestID1, func(rp *dtos.SingularityRequestParent) {

	})

	deployID := "deploy1"
	request1.AddDeploy(deployID, func(dh *dtos.SingularityDeployHistory) {
		dh.DeployResult.DeployState = dtos.SingularityDeployResultDeployStateWAITING
	})

	return fixture, &Deployer{
		Registry:      fixture.Registry,
		ClientFactory: fixture.DeployReaderFactory,
		Clusters:      fixture.Clusters,
	}
}

// defaultExpectedDeployStates returns the expected deploy states generated by
// defaultTextFixture.
func defaultExpectedDeployStates() sous.DeployStates {
	return sous.NewDeployStates(
		&sous.DeployState{
			Status: sous.DeployStatusPending,
			Deployment: sous.Deployment{
				Kind: sous.ManifestKindService,
				SourceID: sous.SourceID{
					Location: sous.SourceLocation{
						Repo: "github.com/user/repo",
						Dir:  "",
					},
					Version: semv.MustParse("1"),
				},
				Flavor:      "",
				ClusterName: "cluster1",
				//Cluster:     cluster,
				DeployConfig: sous.DeployConfig{
					Resources: sous.Resources{
						"cpus":   "0",
						"memory": "0",
						"ports":  "0",
					},
					Volumes: sous.Volumes{
						&sous.Volume{
							Host:      "/onhost",
							Container: "/indocker",
							Mode:      sous.ReadWrite,
						},
					},
				},
			},
		},
	)
}

func TestDeployer_RunningDeployments_defaultTestFixture(t *testing.T) {

	// Setup.
	_, deployer := defaultTestFixture()

	// Act.
	actual, err := deployer.RunningDeployments()
	if err != nil {
		t.Fatal(err) // We are only testing happy paths in this file.
	}

	// Assert.
	expected := defaultExpectedDeployStates()

	different, diffs := actual.Diff2(expected)
	if !different {
		return // Success!
	}
	for _, d := range diffs {
		t.Error(d)
	}
}

//func TestGetDepSetWorks(t *testing.T) {
//	assert := assert.New(t)
//
//	const baseURL = "http://test-singularity.org/"
//	const requestID = "github.com>user>project::cluster1"
//	const deployID = "deploy1"
//	const repo = "github.com/user/project"
//
//	reg := sous.NewDummyRegistry()
//
//	reg.FeedImageLabels(map[string]string{
//		"com.opentable.sous.repo_url":    repo,
//		"com.opentable.sous.version":     "1.0.0",
//		"com.opentable.sous.revision":    "abc123",
//		"com.opentable.sous.repo_offset": "",
//	}, nil)
//
//	testReq := &dtos.SingularityRequestParent{
//		RequestDeployState: &dtos.SingularityRequestDeployState{
//			ActiveDeploy: &dtos.SingularityDeployMarker{
//				DeployId:  deployID,
//				RequestId: requestID,
//			},
//		},
//		Request: &dtos.SingularityRequest{
//			Id:          requestID,
//			RequestType: dtos.SingularityRequestRequestTypeSERVICE,
//			Owners:      swaggering.StringList{"jlester@opentable.com"},
//		},
//	}
//
//	testDep := &dtos.SingularityDeployHistory{
//		Deploy: &dtos.SingularityDeploy{
//			Id: deployID,
//			ContainerInfo: &dtos.SingularityContainerInfo{
//				Type: dtos.SingularityContainerInfoSingularityContainerTypeDOCKER,
//				Docker: &dtos.SingularityDockerInfo{
//					Image: "some-docker-image",
//				},
//				Volumes: dtos.SingularityVolumeList{
//					&dtos.SingularityVolume{
//						HostPath:      "/onhost",
//						ContainerPath: "/indocker",
//						Mode:          dtos.SingularityVolumeSingularityDockerVolumeModeRW,
//					},
//				},
//			},
//			Resources: &dtos.Resources{},
//		},
//	}
//
//	requester := TestGETRequester{}
//	requester.RegisterDTO(&dtos.SingularityRequestParentList{testReq}, "/api/requests")
//	requester.RegisterDTO(testReq, "/api/requests/request/%s", requestID)
//	requester.RegisterDTO(testDep, "/api/history/request/%s/deploy/%s", requestID, deployID)
//
//	client := &singularity.Client{Requester: requester}
//
//	dep := Deployer{
//		Registry:      reg,
//		ClientFactory: func(*sous.Cluster) DeployReader { return client },
//		Clusters:      sous.Clusters{"cluster1": &sous.Cluster{Name: "cluster1", BaseURL: baseURL}},
//	}
//
//	res, err := dep.RunningDeployments()
//
//	if !assert.NoError(err) {
//		t.FailNow()
//	}
//
//	if !assert.NotNil(res) {
//		t.FailNow()
//	}
//
//	actual := res.Snapshot()
//
//	if !assert.Len(actual, 1) {
//		t.FailNow()
//	}
//
//	t.Logf("% #v", res.Snapshot())
//
//	expectedDID := sous.DeployID{
//		ManifestID: sous.ManifestID{
//			Source: sous.SourceLocation{
//				Repo: repo,
//				Dir:  "",
//			},
//			Flavor: "",
//		},
//		Cluster: "cluster1",
//	}
//
//	actualDS, ok := actual[expectedDID]
//	if !ok {
//		var actualDID sous.DeployID
//		for actualDID = range actual {
//			break
//		}
//		t.Fatalf("Got DeployID %q; want DeployID %q", actualDID, expectedDID)
//	}
//
//	expectedDS := //
//	if different, diffs := actualDS.Diff(&expectedDS); different {
//		t.Fatalf("deploy state not as expected: % #v", diffs)
//	}
//
//}
